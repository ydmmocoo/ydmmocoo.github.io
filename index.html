<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="追求技术的路上永远不能停下脚步。。。">
<meta property="og:type" content="website">
<meta property="og:title" content="习惯沉默的Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="习惯沉默的Blog">
<meta property="og:description" content="追求技术的路上永远不能停下脚步。。。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="习惯沉默的Blog">
<meta name="twitter:description" content="追求技术的路上永远不能停下脚步。。。">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>

  <title> 习惯沉默的Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">习惯沉默的Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/15/Retrofit返回Json数据/" itemprop="url">
                  Retrofit返回Json数据
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-15T10:36:21+08:00" content="2016-07-15">
              2016-07-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android开发/" itemprop="url" rel="index">
                    <span itemprop="name">Android开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/15/Retrofit返回Json数据/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/15/Retrofit返回Json数据/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在使用Retrofit的过程中，不需要Gson以及其他转换器，只是单纯的返回 JSONObject，那要怎么处理呢?<br>1.<a href="https://github.com/brokge/Retrofit2.0-JSONCoverter" target="_blank" rel="external">添加自定义Converter</a>(注意选择相对应的版本)<br>2.把GsonConverterFactory.create(或者其他转换器)换成JsonConverterFactory.create()<br>具体代码如下：</p>
<pre><code>private static Retrofit initRetrofit() {
    OkHttpClient httpClient = new OkHttpClient();
    if (BuildConfig.DEBUG) {
        HttpLoggingInterceptor logging = new HttpLoggingInterceptor();
        logging.setLevel(HttpLoggingInterceptor.Level.BODY);
        httpClient = new OkHttpClient.Builder().addInterceptor(logging).build();
    }
    return new Retrofit.Builder()
            .baseUrl(BaseUtil.getApiUrl())
            .addConverterFactory(JsonConverterFactory.create())
            .client(httpClient)
            .build();
}
</code></pre><p>3.请求的接口</p>
<pre><code>public interfase ApiService{
@POST(&quot;/list&quot;)
Call&lt;JSONObject&gt; loadRepo();
}
</code></pre><p>4.调用<br>异步：</p>
<pre><code>Call&lt;JSONObject&gt; call = service.loadRepo();
Repo repo = call.excute()
</code></pre><p>同步：</p>
<pre><code>Call&lt;JSONObject&gt; call = service.loadRepo();
call.enqueue(new Callback&lt;JSONObject&gt;(){
@Override
public void onResponse(Response&lt;JSONObject&gt; response){
    //从response.body()中获取结果
}
@Override
public void onFailure(Throwable t){

}
});
</code></pre><p>JsonConverterFactory github地址：<a href="https://github.com/brokge/Retrofit2.0-JSONCoverter" target="_blank" rel="external">https://github.com/brokge/Retrofit2.0-JSONCoverter</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/30/Android调用微信扫一扫和支付宝扫一扫/" itemprop="url">
                  Android调用微信扫一扫和支付宝扫一扫
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-30T16:59:05+08:00" content="2016-06-30">
              2016-06-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android开发/" itemprop="url" rel="index">
                    <span itemprop="name">Android开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/30/Android调用微信扫一扫和支付宝扫一扫/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/30/Android调用微信扫一扫和支付宝扫一扫/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>近期开发一个项目当中需要先将二维码图片保存到相册，然后再跳转到支付宝、微信扫一扫读取图片中的二维码。</p>
<h2 id="微信"><a href="#微信" class="headerlink" title="微信"></a>微信</h2><p>在自己的应用中打开微信扫一扫代码：</p>
<pre><code>private void toWeChatScan() {
    try {
        //利用Intent打开微信
        Uri uri = Uri.parse(&quot;weixin://dl/scan&quot;);
        Intent intent = new Intent(Intent.ACTION_VIEW, uri);
        startActivity(intent);
    } catch (Exception e) {
        //若无法正常跳转，在此进行错误处理
        Toast.makeText(context, &quot;无法跳转到微信，请检查您是否安装了微信！&quot;, Toast.LENGTH_SHORT).show();
    }
}
</code></pre><p>使用以上代码跳转到微信（版本：6.3.18）扫一扫，会出现以下情况：</p>
<pre><code>     情况                         结果
安装并登陆了微信             跳转到微信扫一扫
安装了但未登陆微信           跳转到微信登陆，登陆成功后跳转到扫一扫
未安装微信                   Toast没安装微信
</code></pre><h2 id="支付宝"><a href="#支付宝" class="headerlink" title="支付宝"></a>支付宝</h2><pre><code>private void toAliPayScan() {
    try {
        //利用Intent打开支付宝
        //支付宝跳过开启动画打开扫码和付款码的url scheme分别是alipayqr://platformapi/startapp?saId=10000007和
        //alipayqr://platformapi/startapp?saId=20000056
        Uri uri = Uri.parse(&quot;alipayqr://platformapi/startapp?saId=10000007&quot;);
        Intent intent = new Intent(Intent.ACTION_VIEW, uri);
        startActivity(intent);
    } catch (Exception e) {
        //若无法正常跳转，在此进行错误处理
        Toast.makeText(context, &quot;无法跳转到支付宝，请检查您是否安装了支付宝！&quot;, Toast.LENGTH_SHORT).show();
    }
}
</code></pre><p>感谢以下作者：<br><a href="http://blog.csdn.net/l_lhc/article/details/51636130" target="_blank" rel="external">Android调用微信扫一扫</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/28/Android-Studio插件整理/" itemprop="url">
                  Android Studio插件整理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-28T09:34:50+08:00" content="2016-06-28">
              2016-06-28
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android开发/" itemprop="url" rel="index">
                    <span itemprop="name">Android开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/28/Android-Studio插件整理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/28/Android-Studio插件整理/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>现在Android的开发者基本上都使用Android Studio进行开发(如果你还在使用eclipse那也行，毕竟你乐意怎么样都行)。使用好Android Studio插件能大量的减少我们的工作量。</p>
<h1 id="1-GsonFormat"><a href="#1-GsonFormat" class="headerlink" title="1.GsonFormat"></a>1.<a href="http://plugins.jetbrains.com/plugin/7654?pr=androidstudio" target="_blank" rel="external">GsonFormat</a></h1><p>快速将json字符串转换成一个Java Bean，免去我们根据json字符串手写对应Java Bean的过程。</p>
<p><img src="http://plugins.jetbrains.com/files/7654/screenshot_15729.png" alt=""></p>
<p>使用方法：快捷键Alt+S也可以使用Alt+Insert选择GsonFormat</p>
<h1 id="2-Android-ButterKnife-Zelezny"><a href="#2-Android-ButterKnife-Zelezny" class="headerlink" title="2.Android ButterKnife Zelezny"></a>2.<a href="http://plugins.jetbrains.com/plugin/7369?pr=androidstudio" target="_blank" rel="external">Android ButterKnife Zelezny</a></h1><p>配合ButterKnife实现注解，从此不用写findViewById，想着就爽啊。在Activity，Fragment，Adapter中选中布局xml的资源id自动生成butterknife注解。</p>
<p><img src="http://plugins.jetbrains.com/files/7369/screenshot_14384.png" alt=""></p>
<p>使用方法：Ctrl+Shift+B选择图上所示选项</p>
<h1 id="3-Android-Code-Generator"><a href="#3-Android-Code-Generator" class="headerlink" title="3.Android Code Generator"></a>3.<a href="http://plugins.jetbrains.com/plugin/7595?pr=androidstudio" target="_blank" rel="external">Android Code Generator</a></h1><p>根据布局文件快速生成对应的Activity，Fragment，Adapter，Menu。</p>
<p><img src="http://plugins.jetbrains.com/files/7595/screenshot_14834.png" alt=""><br><img src="http://plugins.jetbrains.com/files/7595/screenshot_14833.png" alt=""></p>
<h1 id="4-Android-Parcelable-code-generator"><a href="#4-Android-Parcelable-code-generator" class="headerlink" title="4.Android Parcelable code generator"></a>4.<a href="http://plugins.jetbrains.com/plugin/7332?pr=androidstudio" target="_blank" rel="external">Android Parcelable code generator</a></h1><p>JavaBean序列化，快速实现Parcelable接口。</p>
<p><img src="https://segmentfault.com/image?src=http://img.blog.csdn.net/20160416104459926&amp;objectId=1190000005092842&amp;token=ab29ed79d41be9e42b3a3d2ed1ec3bef" alt=""></p>
<h1 id="5-Android-Methods-Count"><a href="#5-Android-Methods-Count" class="headerlink" title="5.Android Methods Count"></a>5.<a href="http://plugins.jetbrains.com/plugin/8076?pr=androidstudio" target="_blank" rel="external">Android Methods Count</a></h1><p>显示依赖库中得方法数</p>
<p><img src="http://plugins.jetbrains.com/files/8076/screenshot_15509.png" alt=""></p>
<h1 id="6-Lifecycle-Sorter"><a href="#6-Lifecycle-Sorter" class="headerlink" title="6.Lifecycle Sorter"></a>6.<a href="http://plugins.jetbrains.com/plugin/7742?pr=androidstudio" target="_blank" rel="external">Lifecycle Sorter</a></h1><p>可以根据Activity或者fragment的生命周期对其生命周期方法位置进行先后排序，快捷键Ctrl + alt + K</p>
<p><img src="http://plugins.jetbrains.com/files/7742/screenshot_15071.png" alt=""><br><img src="http://plugins.jetbrains.com/files/7742/screenshot_15070.png" alt=""></p>
<h1 id="7-CodeGlance"><a href="#7-CodeGlance" class="headerlink" title="7.CodeGlance"></a>7.<a href="http://plugins.jetbrains.com/plugin/7275?pr=androidstudio" target="_blank" rel="external">CodeGlance</a></h1><p>在右边可以预览代码，实现快速定位</p>
<p><img src="http://plugins.jetbrains.com/files/7275/screenshot_14294.png" alt=""><br><img src="http://plugins.jetbrains.com/files/7275/screenshot_14295.png" alt=""></p>
<h1 id="8-findBugs-IDEA"><a href="#8-findBugs-IDEA" class="headerlink" title="8.findBugs-IDEA"></a>8.<a href="http://plugins.jetbrains.com/plugin/3847?pr=androidstudio" target="_blank" rel="external">findBugs-IDEA</a></h1><p>查找bug的插件，Android Studio也提供了代码审查的功能（Analyze-Inspect Code…）</p>
<p><img src="http://plugins.jetbrains.com/oldimg/screenshots/FindBugs-IDEA_2541.png" alt=""></p>
<h1 id="9-ADB-WIFI"><a href="#9-ADB-WIFI" class="headerlink" title="9.ADB WIFI"></a>9.<a href="http://plugins.jetbrains.com/plugin/7856?pr=androidstudio" target="_blank" rel="external">ADB WIFI</a></h1><p>使用wifi无线调试你的app，无需root权限<br>也可参考以下文章：<br><a href="http://www.jianshu.com/p/21d1b65d92a4" target="_blank" rel="external">Android wifi无线调试App新玩法ADB WIFI</a></p>
<p><img src="http://plugins.jetbrains.com/files/7856/screenshot_15153.png" alt=""></p>
<h1 id="10-AndroidPixelDimenGenerator"><a href="#10-AndroidPixelDimenGenerator" class="headerlink" title="10.AndroidPixelDimenGenerator"></a>10.<a href="https://github.com/succlz123/AndroidPixelDimenGenerator" target="_blank" rel="external">AndroidPixelDimenGenerator</a></h1><p>Android Studio自动生成dimen.xml文件插件</p>
<p><img src="https://github.com/succlz123/AndroidPixelDimenGenerator/raw/master/snapshot/1.jpeg" alt=""></p>
<h1 id="11-JsonOnlineViewer"><a href="#11-JsonOnlineViewer" class="headerlink" title="11.JsonOnlineViewer"></a>11.<a href="http://plugins.jetbrains.com/plugin/7838?pr=androidstudio" target="_blank" rel="external">JsonOnlineViewer</a></h1><p>在Android Studio中请求、调试接口</p>
<p><img src="http://plugins.jetbrains.com/files/7838/screenshot_15113.png" alt=""></p>
<h1 id="12-Android-Styler"><a href="#12-Android-Styler" class="headerlink" title="12.Android Styler"></a>12.<a href="http://plugins.jetbrains.com/plugin/7972?pr=androidstudio" target="_blank" rel="external">Android Styler</a></h1><p>根据xml自动生成style代码的插件</p>
<p><img src="http://plugins.jetbrains.com/files/7972/screenshot_15340.png" alt=""><br><img src="http://plugins.jetbrains.com/files/7972/screenshot_15339.png" alt=""><br><img src="http://plugins.jetbrains.com/files/7972/screenshot_15338.png" alt=""></p>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage:"></a>Usage:</h2><p>a. copy lines with future style from your layout.xml file<br>b. paste it to styles.xml file with Ctrl+Shift+D (or context menu)<br>c. enter name of new style in the modal window<br>d. your style is prepared! </p>
<h1 id="13-Android-Drawable-Importer"><a href="#13-Android-Drawable-Importer" class="headerlink" title="13.Android Drawable Importer"></a>13.<a href="http://plugins.jetbrains.com/plugin/7658?pr=androidstudio" target="_blank" rel="external">Android Drawable Importer</a></h1><p>这是一个非常强大的图片导入插件。它导入Android图标与Material图标的Drawable ，批量导入Drawable ，多源导入Drawable（即导入某张图片各种dpi对应的图片）</p>
<p><img src="http://plugins.jetbrains.com/files/7658/screenshot_15535.png" alt=""><br><img src="http://plugins.jetbrains.com/files/7658/screenshot_15691.png" alt=""><br><img src="http://plugins.jetbrains.com/files/7658/screenshot_15533.png" alt=""><br><img src="http://plugins.jetbrains.com/files/7658/screenshot_15537.png" alt=""><br><img src="http://plugins.jetbrains.com/files/7658/screenshot_15536.png" alt=""><br><img src="http://plugins.jetbrains.com/files/7658/screenshot_15534.png" alt=""><br><img src="http://plugins.jetbrains.com/files/7658/screenshot_15532.png" alt=""><br><img src="http://plugins.jetbrains.com/files/7658/screenshot_15351.png" alt=""></p>
<h1 id="14-SelectorChapek-for-Android"><a href="#14-SelectorChapek-for-Android" class="headerlink" title="14.SelectorChapek for Android"></a>14.<a href="http://plugins.jetbrains.com/plugin/7298?pr=androidstudio" target="_blank" rel="external">SelectorChapek for Android</a></h1><p>通过资源文件命名自动生成Selector文件。</p>
<p><img src="http://plugins.jetbrains.com/files/7298/screenshot_14292.png" alt=""><br><img src="http://plugins.jetbrains.com/files/7298/screenshot_14291.png" alt=""><br><img src="http://plugins.jetbrains.com/files/7298/screenshot_14290.png" alt=""></p>
<h1 id="15-GenerateSerialVersionUID"><a href="#15-GenerateSerialVersionUID" class="headerlink" title="15.GenerateSerialVersionUID"></a>15.<a href="http://plugins.jetbrains.com/plugin/185?pr=androidstudio" target="_blank" rel="external">GenerateSerialVersionUID</a></h1><p>实现Serializable序列化bean</p>
<p>Adds a new action ‘SerialVersionUID’ in the generate menu (alt + ins). The action adds an serialVersionUID field in the current class or updates it if it already exists, and assigns it the same value the standard ‘serialver’ JDK tool would return. The action is only visible when IDEA is not rebuilding its indexes, the class is serializable and either no serialVersionUID field exists or its value is different from the one the ‘serialver’ tool would return.</p>
<h1 id="16-genymotion"><a href="#16-genymotion" class="headerlink" title="16.genymotion"></a>16.<a href="http://plugins.jetbrains.com/plugin/7269?pr=androidstudio" target="_blank" rel="external">genymotion</a></h1><p>速度较快的android模拟器</p>
<p><img src="http://plugins.jetbrains.com/files/7269/screenshot_14278.png" alt=""></p>
<h1 id="17-SQLScout"><a href="#17-SQLScout" class="headerlink" title="17.SQLScout"></a>17.<a href="https://plugins.jetbrains.com/plugin/8322-sqlscout-sqlite-support-" target="_blank" rel="external">SQLScout</a></h1><p>在 Android Studio 上调试数据库 ( SQLite )</p>
<p>详细使用参考：<a href="https://juejin.im/post/58e0d781a0bb9f0069ec08d3" target="_blank" rel="external">在 Android Studio 上调试数据库 ( SQLite )</a></p>
<p><img src="https://plugins.jetbrains.com/files/8322/screenshot_15823.png" alt=""></p>
<h1 id="18-Android-Postfix-Completion"><a href="#18-Android-Postfix-Completion" class="headerlink" title="18.Android Postfix Completion"></a>18.<a href="http://plugins.jetbrains.com/plugin/7775?pr=androidstudio" target="_blank" rel="external">Android Postfix Completion</a></h1><p>可根据后缀快速完成代码，这个属于拓展吧，系统已经有这些功能，如sout、notnull等，这个插件在原有的基础上增添了一些新的功能，我更想做的是通过原作者的代码自己定制功能，那就更爽了</p>
<p><img src="http://plugins.jetbrains.com/files/7775/screenshot_15042.png" alt=""></p>
<h1 id="19-Android-Holo-Colors-Generator"><a href="#19-Android-Holo-Colors-Generator" class="headerlink" title="19.Android Holo Colors Generator"></a>19.<a href="https://plugins.jetbrains.com/plugin/7366?pr=" target="_blank" rel="external">Android Holo Colors Generator</a></h1><p>通过自定义Holo主题颜色生成对应的Drawable和布局文件</p>
<p><img src="https://plugins.jetbrains.com/files/7366/screenshot_14379.png" alt=""></p>
<h1 id="20-dagger-intellij-plugin"><a href="#20-dagger-intellij-plugin" class="headerlink" title="20.dagger-intellij-plugin"></a>20.<a href="https://github.com/square/dagger-intellij-plugin" target="_blank" rel="external">dagger-intellij-plugin</a></h1><p>dagger可视化辅助工具</p>
<p><img src="https://github.com/square/dagger-intellij-plugin/raw/master/images/inject-to-provide.gif" alt=""></p>
<h1 id="21-GradleDependenciesHelperPlugin"><a href="#21-GradleDependenciesHelperPlugin" class="headerlink" title="21.GradleDependenciesHelperPlugin"></a>21.<a href="https://github.com/ligi/GradleDependenciesHelperPlugin" target="_blank" rel="external">GradleDependenciesHelperPlugin</a></h1><p>maven gradle 依赖支持自动补全</p>
<p><img src="https://camo.githubusercontent.com/d9b1b39eda21e0e33b656e2821f01897d915f7c5/68747470733a2f2f6c68332e676f6f676c6575736572636f6e74656e742e636f6d2f2d51364e7970315864594c772f556a73325a5175666634492f414141414141414144624d2f624d704c516742664d6b632f773538372d683330392d6e6f2f696465615f677261646c655f706c7567696e2e706e67" alt=""></p>
<h1 id="22-RemoveButterKnife"><a href="#22-RemoveButterKnife" class="headerlink" title="22.RemoveButterKnife"></a>22.<a href="https://github.com/u3shadow/RemoveButterKnife" target="_blank" rel="external">RemoveButterKnife</a></h1><p>ButterKnife这个第三方库每次更新之后，绑定view的注解都会改变，从bind,到inject，再到bindview，搞得很多人都不敢升级，一旦升级，就会有巨量的代码需要手动修改，非常痛苦<br>当我们有一些非常棒的代码需要拿到其他项目使用，但是我们发现，那个项目对第三方库的使用是有限制的，我们不能使用butterknife，这时候，我们又得从注解改回findviewbyid<br>针对上面的两种情况，如果view比较少还好说，如果有几十个view，那么我们一个个的手动删除注解，写findviewbyid语句，简直是一场噩梦（别问我为什么知道这是噩梦）<br>所以，这种有规律又重复简单的工作为什么不能用一个插件来实现呢？于是RemoveButterKnife的想法就出现了。</p>
<p><a href="http://www.u3coding.com/2016/06/24/androidstudio-plugin-removebutterknife-di/" target="_blank" rel="external">具体介绍</a></p>
<p><img src="https://camo.githubusercontent.com/0327cda5b531ab6f2b803abe295c42225668d28d/687474703a2f2f7777772e7533636f64696e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031362f30362f312e676966" alt=""></p>
<h1 id="23-AndroidProguardPlugin"><a href="#23-AndroidProguardPlugin" class="headerlink" title="23.AndroidProguardPlugin"></a>23.<a href="https://github.com/zhonghanwen/AndroidProguardPlugin" target="_blank" rel="external">AndroidProguardPlugin</a></h1><p>一键生成项目混淆代码插件，值得你安装~(不过目前可能有些第三方项目的混淆还未添加完全)</p>
<p><img src="http://7xrnko.com1.z0.glb.clouddn.com/androidproguard1.gif" alt=""></p>
<h1 id="24-otto-intellij-plugin"><a href="#24-otto-intellij-plugin" class="headerlink" title="24.otto-intellij-plugin"></a>24.<a href="https://github.com/square/otto-intellij-plugin" target="_blank" rel="external">otto-intellij-plugin</a></h1><p>otto事件导航工具。</p>
<p><img src="https://github.com/square/otto-intellij-plugin/raw/master/images/produce-to-subscribe.gif" alt=""><br><img src="https://github.com/square/otto-intellij-plugin/raw/master/images/event-to-subscribe.gif" alt=""></p>
<h1 id="25-eventbus-intellij-plugin"><a href="#25-eventbus-intellij-plugin" class="headerlink" title="25.eventbus-intellij-plugin"></a>25.<a href="https://github.com/kgmyshin/eventbus-intellij-plugin" target="_blank" rel="external">eventbus-intellij-plugin</a></h1><p>eventbus导航插件(对于最新版的 EventBus 3.0.0 好像无效,请替换为eventbus3-intellij-plugin此插件地址在本文第51个)</p>
<p><img src="https://raw.githubusercontent.com/kgmyshin/eventbus-intellij-plugin/master/art/cap.gif" alt=""></p>
<h1 id="26-idea-markdown"><a href="#26-idea-markdown" class="headerlink" title="26.idea-markdown"></a>26.<a href="https://github.com/nicoulaj/idea-markdown" target="_blank" rel="external">idea-markdown</a></h1><p>markdown插件</p>
<p><img src="https://github.com/nicoulaj/idea-markdown/raw/assets/screenshots/preview.png" alt=""></p>
<h1 id="27-Sexy-Editor"><a href="#27-Sexy-Editor" class="headerlink" title="27.Sexy Editor"></a>27.<a href="https://plugins.jetbrains.com/plugin/1833?pr=androidstudio" target="_blank" rel="external">Sexy Editor</a></h1><p>设置AS代码编辑区的背景图</p>
<p>首先点击界面的设置按钮 进入设置界面，选中Plugins,右边选择 Browser … ，输入Sexy … 下面自动弹出候选插件，右边点击Install 安装<br><img src="http://d.hiphotos.baidu.com/zhidao/wh%3D600%2C800/sign=f57bdd37f0246b607b5bba72dbc83674/4b90f603738da9777260054fb651f8198618e303.jpg" alt=""><br>安装成功 后需要重启AS<br><img src="http://h.hiphotos.baidu.com/zhidao/wh%3D600%2C800/sign=77e4e517fdf2b211e47b8d48fab04900/1c950a7b02087bf46d0dd48df4d3572c10dfcff5.jpg" alt=""><br>重启完成之后 进入设置界面 选择other Setting 下的Sexy Editor ， 右侧 insert 一张或多张图片即可，上面的其他设置可以设置方位 间隔时间 透明度等等，设置完成后，要关闭打开的文件，重新打开项目文件即可在代码编辑区显示插入的图片，作为代码编辑区的背景图。<br><img src="http://h.hiphotos.baidu.com/zhidao/wh%3D600%2C800/sign=5cd9b28564d9f2d320442ce999dca62b/34fae6cd7b899e51289eb77044a7d933c8950d45.jpg" alt=""></p>
<h1 id="28-folding-plugin"><a href="#28-folding-plugin" class="headerlink" title="28.folding-plugin"></a>28.<a href="https://github.com/dmytrodanylyk/folding-plugin" target="_blank" rel="external">folding-plugin</a></h1><p>布局文件分组的插件</p>
<p><img src="https://github.com/dmytrodanylyk/folding-plugin/raw/master/screenshots/Preview.png" alt=""></p>
<h1 id="29-Android-DPI-Calculator"><a href="#29-Android-DPI-Calculator" class="headerlink" title="29.Android-DPI-Calculator"></a>29.<a href="https://github.com/JerzyPuchalski/Android-DPI-Calculator" target="_blank" rel="external">Android-DPI-Calculator</a></h1><p>DPI计算插件</p>
<p><img src="https://camo.githubusercontent.com/ce3be2aaa3b1f70b90f5b825c529694509d70313/68747470733a2f2f7261772e6769746875622e636f6d2f4a65727a7950756368616c736b692f416e64726f69642d4450492d43616c63756c61746f722f6d61737465722f696d672f6469616c6f672e706e67" alt=""></p>
<p>使用：<br><img src="https://camo.githubusercontent.com/598d3b5c9efc5f0b57b58c25a79a323d06307fad/68747470733a2f2f7261772e6769746875622e636f6d2f4a65727a7950756368616c736b692f416e64726f69642d4450492d43616c63756c61746f722f6d61737465722f696d672f616374696f6e2e706e67" alt=""><br>或者<br><img src="https://camo.githubusercontent.com/7a8f977de7a1ba6cd23fb64cbd37566690c27cdc/68747470733a2f2f7261772e6769746875622e636f6d2f4a65727a7950756368616c736b692f416e64726f69642d4450492d43616c63756c61746f722f6d61737465722f696d672f6d656e752e706e67" alt=""></p>
<h1 id="30-gradle-retrolambda"><a href="#30-gradle-retrolambda" class="headerlink" title="30.gradle-retrolambda"></a>30.<a href="https://github.com/evant/gradle-retrolambda" target="_blank" rel="external">gradle-retrolambda</a></h1><p>在java 6 7中使用 lambda表达式插件</p>
<p>修改编译的jdk为java8:<br><img src="http://img.blog.csdn.net/20160311101644127" alt=""></p>
<h1 id="31-Android-Studio-Prettify"><a href="#31-Android-Studio-Prettify" class="headerlink" title="31.Android Studio Prettify"></a>31.<a href="https://plugins.jetbrains.com/plugin/7405" target="_blank" rel="external">Android Studio Prettify</a></h1><p>可以将代码中的字符串写在string.xml文件中</p>
<p>选中字符串鼠标右键选择图中所示<br><img src="https://plugins.jetbrains.com/files/7405/screenshot_14417.png" alt=""></p>
<p>这个插件还可以自动书写findViewById<br><img src="https://plugins.jetbrains.com/files/7405/screenshot_14418.png" alt=""></p>
<p><img src="https://plugins.jetbrains.com/files/7405/screenshot_14416.png" alt=""></p>
<p><img src="https://plugins.jetbrains.com/files/7405/screenshot_14501.png" alt=""></p>
<p><img src="https://plugins.jetbrains.com/files/7405/screenshot_14419.png" alt=""></p>
<p><img src="https://plugins.jetbrains.com/files/7405/screenshot_14415.png" alt=""></p>
<h1 id="32-Material-Theme-UI"><a href="#32-Material-Theme-UI" class="headerlink" title="32.Material Theme UI"></a>32.<a href="https://plugins.jetbrains.com/plugin/8006?pr=" target="_blank" rel="external">Material Theme UI</a></h1><p>添加Material主题到你的AS</p>
<p><img src="https://plugins.jetbrains.com/files/8006/screenshot_15722.png" alt=""></p>
<p><img src="https://plugins.jetbrains.com/files/8006/screenshot_15723.png" alt=""></p>
<p><img src="https://plugins.jetbrains.com/files/8006/screenshot_15721.png" alt=""></p>
<h1 id="33-ignore"><a href="#33-ignore" class="headerlink" title="33..ignore"></a>33.<a href="https://plugins.jetbrains.com/plugin/7495?pr=" target="_blank" rel="external">.ignore</a></h1><p>我们都知道在Git 中想要过滤掉一些不想提交的文件，可以把相应的文件添加到.gitignore 中，而.gitignore 这个Android Studio 插件根据不同的语言来选择模板，就不用自己在费事添加一些文件了，而且还有自动补全功能，过滤文件再也不要复制文件名了。我们做项目的时候，并不是所有文件都是要提交的，比如构建的build 文件夹，本地配置文件，每个Module 生成的iml 文件，但是我们每次add，commit 都会不小心把它们添加上去，而gitignore 就是解决这种痛点的，如果你不想提交的文件，就可以在创建项目的时候将这个文件中添加即可，将一些通用的东西屏蔽掉。</p>
<p><img src="https://plugins.jetbrains.com/files/7495/screenshot_14960.png" alt=""></p>
<p><img src="https://plugins.jetbrains.com/files/7495/screenshot_14958.png" alt=""></p>
<p><img src="https://plugins.jetbrains.com/files/7495/screenshot_14959.png" alt=""></p>
<h1 id="34-CheckStyle-IDEA"><a href="#34-CheckStyle-IDEA" class="headerlink" title="34.CheckStyle-IDEA"></a>34.<a href="https://plugins.jetbrains.com/plugin/1065?pr=" target="_blank" rel="external">CheckStyle-IDEA</a></h1><p>CheckStyle-IDEA 是一个检查代码风格的插件，比如像命名约定，Javadoc，类设计等方面进行代码规范和风格的检查，你们可以遵从像Google Oracle 的Java 代码指南 ，当然也可以按照自己的规则来设置配置文件，从而有效约束你自己更好地遵循代码编写规范。</p>
<h1 id="35-Markdown-Navigator"><a href="#35-Markdown-Navigator" class="headerlink" title="35.Markdown Navigator"></a>35.<a href="https://plugins.jetbrains.com/plugin/7896?pr=" target="_blank" rel="external">Markdown Navigator</a></h1><p>github:<a href="https://github.com/vsch/idea-multimarkdown/wiki" target="_blank" rel="external">Markdown Navigator</a><br>Markdown插件</p>
<p><img src="https://plugins.jetbrains.com/files/7896/screenshot_15818.png" alt=""></p>
<h1 id="36-ECTranslation"><a href="#36-ECTranslation" class="headerlink" title="36.ECTranslation"></a>36.<a href="https://github.com/Skykai521/ECTranslation" target="_blank" rel="external">ECTranslation</a></h1><p>Android Studio Plugin,Translate English to Chinese. Android Studio 翻译插件,可以将英文翻译为中文。</p>
<p><img src="https://github.com/Skykai521/ECTranslation/raw/master/img/translation_img.png" alt=""></p>
<h1 id="37-PermissionsDispatcher-plugin"><a href="#37-PermissionsDispatcher-plugin" class="headerlink" title="37.PermissionsDispatcher plugin"></a>37.<a href="https://plugins.jetbrains.com/plugin/8349" target="_blank" rel="external">PermissionsDispatcher plugin</a></h1><p>github:<a href="https://github.com/shiraji/permissions-dispatcher-plugin" target="_blank" rel="external">PermissionsDispatcher plugin</a><br>自动生成6.0权限的代码</p>
<p><img src="https://github.com/shiraji/permissions-dispatcher-plugin/raw/master/website/images/pd.gif" alt=""></p>
<h1 id="38-WakaTime"><a href="#38-WakaTime" class="headerlink" title="38.WakaTime"></a>38.<a href="https://plugins.jetbrains.com/plugin/7425?pr=" target="_blank" rel="external">WakaTime</a></h1><p>github:<a href="https://github.com/wakatime/jetbrains-wakatime" target="_blank" rel="external">WakaTime</a><br>记录你在IDE上的工作时间</p>
<p><img src="https://plugins.jetbrains.com/files/7425/screenshot_14794.png" alt=""></p>
<h1 id="39-AndroidWiFiADB"><a href="#39-AndroidWiFiADB" class="headerlink" title="39.AndroidWiFiADB"></a>39.<a href="https://github.com/pedrovgs/AndroidWiFiADB" target="_blank" rel="external">AndroidWiFiADB</a></h1><p>无线调试应用</p>
<p><img src="https://github.com/pedrovgs/AndroidWiFiADB/raw/master/art/screenshot1.gif" alt=""></p>
<p><img src="https://github.com/pedrovgs/AndroidWiFiADB/raw/master/art/android_devices_window.png" alt=""></p>
<h1 id="40-AndroidLocalizationer"><a href="#40-AndroidLocalizationer" class="headerlink" title="40.AndroidLocalizationer"></a>40.<a href="https://github.com/westlinkin/AndroidLocalizationer" target="_blank" rel="external">AndroidLocalizationer</a></h1><p>可用于将项目中的 string 资源自动翻译为其他语言的 Android Studio/IntelliJ IDEA 插件</p>
<p><img src="https://raw.githubusercontent.com/westlinkin/AndroidLocalizationer/master/screen_shot_3.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/westlinkin/AndroidLocalizationer/master/screen_shot_2.png" alt=""></p>
<h1 id="41-TranslationPlugin"><a href="#41-TranslationPlugin" class="headerlink" title="41.TranslationPlugin"></a>41.<a href="https://github.com/YiiGuxing/TranslationPlugin" target="_blank" rel="external">TranslationPlugin</a></h1><p>又一翻译插件,可中英互译。</p>
<p><img src="https://raw.githubusercontent.com/YiiGuxing/TranslationPlugin/master/images/1.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/YiiGuxing/TranslationPlugin/master/images/3.png" alt=""></p>
<h1 id="42-SingletonTest"><a href="#42-SingletonTest" class="headerlink" title="42.SingletonTest"></a>42.<a href="https://github.com/luhaoaimama1/SingletonTest" target="_blank" rel="external">SingletonTest</a></h1><p>快速生成单例模式的预设</p>
<p><img src="https://github.com/luhaoaimama1/SingletonTest/raw/master/demo/tip1.png" alt=""></p>
<p><img src="https://github.com/luhaoaimama1/SingletonTest/raw/master/demo/tip2.png" alt=""></p>
<p><img src="https://github.com/luhaoaimama1/SingletonTest/raw/master/demo/tip3.png" alt=""></p>
<h1 id="43-BorePlugin"><a href="#43-BorePlugin" class="headerlink" title="43.BorePlugin"></a>43.<a href="https://github.com/boredream/BorePlugin" target="_blank" rel="external">BorePlugin</a></h1><p>Android Studio 自动生成布局代码插件</p>
<p><img src="https://github.com/boredream/BorePlugin/raw/master/screenshot/LayoutCreator.gif" alt=""></p>
<h2 id="代码生成规则"><a href="#代码生成规则" class="headerlink" title="代码生成规则"></a>代码生成规则</h2><p>a.自动遍历目标布局中所有带id的文件, 无id的不会识别处理<br>b.控件生成的变量名默认为id名称, 可以在弹出确认框右侧的名称输入栏中自行修改<br>c.所有的Button或者带clickable=true的控件, 都会自动在代码中生成setOnClickListener相关代码<br>d.所有EditText控件, 都会在代码中生成非空判断代码, 如果为空会提示EditText的hint内容, 如果hint为空则提示xxx字符串不能为空字样, 最后会把所有输入框的验证合并到一个submit方法中<br>e.会自动识别布局中的include标签, 并读取对应布局中的控件</p>
<h1 id="44-jimu-Mirror"><a href="#44-jimu-Mirror" class="headerlink" title="44.jimu Mirror"></a>44.<a href="http://www.jimumirror.com/mirror-downloads/" target="_blank" rel="external">jimu Mirror</a></h1><p>能够实时预览Android布局，它会监听布局文件的改动，如果有代码变化，就会立即刷新UI。</p>
<h1 id="45-jRebel-For-Android"><a href="#45-jRebel-For-Android" class="headerlink" title="45.jRebel For Android"></a>45.<a href="http://zeroturnaround.com/software/jrebel-for-android/" target="_blank" rel="external">jRebel For Android</a></h1><p>不仅能够做到UI布局的实时预览，它甚至做到了让你更改java代码后就能实时替换apk中的类文件，达到应用实时刷新，官网的介绍是：Skip build, install and run，因此它可以节约我们很多很多的时间，它的效果也十分不错。</p>
<p><img src="http://zeroturnaround.com/wp-content/uploads/2015/04/Android_Card1_2x.png" alt=""></p>
<p><img src="http://zeroturnaround.com/wp-content/uploads/2015/04/Android_Card2_2x.png" alt=""></p>
<p><img src="http://zeroturnaround.com/wp-content/uploads/2015/04/Android_Card3_2x.png" alt=""></p>
<h1 id="46-sdk-manager-plugin"><a href="#46-sdk-manager-plugin" class="headerlink" title="46.sdk-manager-plugin"></a>46.<a href="https://github.com/JakeWharton/sdk-manager-plugin" target="_blank" rel="external">sdk-manager-plugin</a></h1><p>SDK管理插件，自动检测更新并下载。(图片与插件无关哈)</p>
<p><img src="https://camo.githubusercontent.com/95469d65798f62a50a9fcabe21e2cc303a1b859c/687474703a2f2f692e696d6775722e636f6d2f384a734a587a6e2e6a7067" alt=""></p>
<h1 id="47-Codota"><a href="#47-Codota" class="headerlink" title="47.Codota"></a>47.<a href="http://www.codota.com/" target="_blank" rel="external">Codota</a></h1><p>搜索最好的Android代码。(Studio里面直接可以搜到此插件)</p>
<h1 id="48-LayoutFormatter"><a href="#48-LayoutFormatter" class="headerlink" title="48.LayoutFormatter"></a>48.<a href="https://github.com/drakeet/LayoutFormatter" target="_blank" rel="external">LayoutFormatter</a></h1><p>drakeet 开发一个一键格式化你的 XML 文件的 Android Studio 插件，至于为什么不用 Android Studio 自带的格式化功能而用这个插件，可以看下作者的一篇 Blog -&gt; <a href="https://drakeet.me/layoutformatter" target="_blank" rel="external">当我们谈 XML 布局文件代码的优雅性</a></p>
<p><img src="http://ww1.sinaimg.cn/large/86e2ff85gw1f383wa95tej21ge0m5ai0.jpg" alt=""></p>
<h1 id="49-android-strings-search-plugin"><a href="#49-android-strings-search-plugin" class="headerlink" title="49.android-strings-search-plugin"></a>49.<a href="https://github.com/konifar/android-strings-search-plugin" target="_blank" rel="external">android-strings-search-plugin</a></h1><p>一个可以通过输入文字找到strings.xml资源的插件</p>
<p><img src="https://github.com/konifar/android-strings-search-plugin/raw/master/art/demo.gif" alt=""></p>
<h1 id="50-ideaVim"><a href="#50-ideaVim" class="headerlink" title="50.ideaVim"></a>50.<a href="http://plugins.jetbrains.com/plugin/164?pr=androidstudio" target="_blank" rel="external">ideaVim</a></h1><p>vim 本身就是一款很优秀的文本编辑器，而Android Studio 更是一款编写APP应用的神器。如果两个款优秀的软件结合在一起感觉会怎样呢？<br>详细请看文章:<a href="http://www.jianshu.com/p/43862126b88f" target="_blank" rel="external">Android Studio ＋Vim</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1825722-8b55d9654777599e.gif?imageMogr2/auto-orient/strip" alt=""></p>
<h1 id="51-eventbus3-intellij-plugin"><a href="#51-eventbus3-intellij-plugin" class="headerlink" title="51.eventbus3-intellij-plugin"></a>51.<a href="https://github.com/likfe/eventbus3-intellij-plugin/blob/master/README-zh.md" target="_blank" rel="external">eventbus3-intellij-plugin</a></h1><p>引导 EventBus 的 post 和 event(对于最新版的 EventBus 3.0.0 有效)<br>主要Bug修复工作：<br>修改包名和方法名以适应 EventBus 3.X<br>替换一个在新版的 intellij plugin SDK 已经不存在的类<br>增加若干 try-catch ，防止插件崩溃</p>
<p><img src="https://raw.githubusercontent.com/likfe/eventbus3-intellij-plugin/master/art/cap.gif" alt=""></p>
<h1 id="52-Exynap"><a href="#52-Exynap" class="headerlink" title="52.Exynap"></a>52.<a href="http://exynap.com/" target="_blank" rel="external">Exynap</a></h1><p>Exynap 一个帮助开发者自动生成样板代码的 AndroidStudio 插件</p>
<p><img src="http://exynap.com/images/anim01.gif" alt=""></p>
<h1 id="53-gradle-cleaner-intellij-plugin"><a href="#53-gradle-cleaner-intellij-plugin" class="headerlink" title="53.gradle-cleaner-intellij-plugin"></a>53.<a href="https://github.com/Softwee/gradle-cleaner-intellij-plugin" target="_blank" rel="external">gradle-cleaner-intellij-plugin</a></h1><p>Force clear delaying &amp; no longer needed Gradle tasks.</p>
<p><img src="https://camo.githubusercontent.com/cb48bca7f8bd0b513f350f7320c74054d1b9fbce/687474703a2f2f6936352e74696e797069632e636f6d2f726a687863382e706e67" alt=""></p>
<h1 id="54-MVPHelper"><a href="#54-MVPHelper" class="headerlink" title="54.MVPHelper"></a>54.<a href="http://androidwing.net/index.php/27" target="_blank" rel="external">MVPHelper</a></h1><p>一款Intellj IDEA 和Android Studio的插件，可以为MVP生成接口以及实现类，解放双手。<br>具体请查看<a href="http://androidwing.net/index.php/27" target="_blank" rel="external">Android Studio插件之MVPHelper，一键生成MVP代码</a>一文</p>
<p><img src="https://github.com/githubwing/MVPHelper/raw/master/img/mvp_presenter.gif" alt=""></p>
<h1 id="55-Matchmaker"><a href="#55-Matchmaker" class="headerlink" title="55.Matchmaker"></a>55.<a href="https://github.com/lypeer/Matchmaker" target="_blank" rel="external">Matchmaker</a></h1><p>这是一款专为微信小程序开发的插件，目前可在 IntelliJ IDEA 中使用。它可以帮你完成重复机械无趣麻烦的绑定方法的过程，自动的将需要新建的方法注入到 js 文件中去。</p>
<p><img src="https://raw.githubusercontent.com/lypeer/Matchmaker/master/gif/plugin.gif" alt=""></p>
<h1 id="56-Emoji-Support-Plugin"><a href="#56-Emoji-Support-Plugin" class="headerlink" title="56.Emoji Support Plugin"></a>56.<a href="https://plugins.jetbrains.com/plugin/9174" target="_blank" rel="external">Emoji Support Plugin</a></h1><p>让 Intellij 支持 Emoji 输入提醒</p>
<p><img src="https://github.com/shiraji/emoji/raw/master/website/images/commit.gif" alt=""></p>
<h1 id="57-Open-Uploader"><a href="#57-Open-Uploader" class="headerlink" title="57.Open-Uploader"></a>57.<a href="https://github.com/fingerart/Open-Uploader" target="_blank" rel="external">Open-Uploader</a></h1><p>上传apk文件到指定的地址，提供自定义参数</p>
<p><img src="https://camo.githubusercontent.com/aa9d4468da25629928fc71256834a81fdaf2bebc/687474703a2f2f66696e6765726172742e71696e6975646e2e636f6d2f323031362d31302d31322d6f70656e5f75706c6f616465725f707265766965772e676966" alt=""></p>
<h1 id="58-MultiTypeTemplates"><a href="#58-MultiTypeTemplates" class="headerlink" title="58.MultiTypeTemplates"></a>58.<a href="https://github.com/drakeet/MultiTypeTemplates" target="_blank" rel="external">MultiTypeTemplates</a></h1><p>生成MultiType和itemviewprovider(关于MultiType请查看<a href="http://gank.io/post/5823bcf6421aa90e799ec2ad" target="_blank" rel="external">Android 复杂的列表视图新写法 MultiType</a>)</p>
<p><img src="https://camo.githubusercontent.com/d43ec0344dcce348e663ba57303fa6a26e4d1bf2/687474703a2f2f7777342e73696e61696d672e636e2f6c617267652f3836653266663835677731663933356c306b77696c6a32316b77307433616b6d2e6a7067" alt=""></p>
<p><img src="https://camo.githubusercontent.com/1eb2599f0689134d0bfc728b0ae38a4ead4010d3/687474703a2f2f7777342e73696e61696d672e636e2f6c617267652f38366532666638356777316638796a3073656a64366a323133343062656e31732e6a7067" alt=""></p>
<h1 id="59-Android-ButterKnife-Plugin-Plus"><a href="#59-Android-ButterKnife-Plugin-Plus" class="headerlink" title="59.Android-ButterKnife-Plugin-Plus"></a>59.<a href="https://github.com/OriginalLove/Android-ButterKnife-Plugin-Plus" target="_blank" rel="external">Android-ButterKnife-Plugin-Plus</a></h1><p>Android Studio 的插件，方便快速实现ButterKnife注解框架，包含了android-butterknife-zelezny 1.6版本的所有功能，并在此基础上新增如下功能：</p>
<p>1.可以自由选择是否在当前类中对ButterKnife进行初始化，避免了原版本只要使用插件初始化控件会自动在onCreate中进行ButterKnife.bind(this)的尴尬。</p>
<p><img src="https://github.com/OriginalLove/Android-ButterKnife-Plugin-Plus/raw/master/img/1.png" alt=""></p>
<p>这样就可以在基类中进行ButterKnife的初始化，不必要每个类中都要初始化，对开发框架的搭建更加方便。</p>
<p>2.在Android Studio的设置界面，对在当前类中是否强制初始化提供了默认值设置，这样就可以让插件使用更符合自己的操作习惯。</p>
<p><img src="https://github.com/OriginalLove/Android-ButterKnife-Plugin-Plus/raw/master/img/2.png" alt=""></p>
<h1 id="60-ApkMultiChannelPlugin"><a href="#60-ApkMultiChannelPlugin" class="headerlink" title="60. ApkMultiChannelPlugin"></a>60. <a href="https://github.com/nukc/ApkMultiChannelPlugin" target="_blank" rel="external">ApkMultiChannelPlugin</a></h1><p>这是一个为了方便 Android 多渠道打包的 Android Studio / IDEA 插件</p>
<p><strong>安装:</strong></p>
<ul>
<li>打开 Android Studio: 打开 Setting/Preferences -&gt; Plugins -&gt; Browse repositories 然后搜索 ApkMultiChannel 安装重启</li>
</ul>
<p>或者</p>
<ul>
<li>下载 <a href="https://plugins.jetbrains.com/idea/plugin/9369" target="_blank" rel="external">ApkMultiChannelPlugin.jar</a> 然后 Setting/Preferences -&gt; Plugins -&gt; Install plugin from disk 选择 ApkMultiChannelPlugin.jar 安装重启</li>
</ul>
<p><strong>使用方式:</strong></p>
<ol>
<li><p>选择 apk</p>
<p>选择一个 apk 然后右键，点击 Build MultiChannel<br><img src="https://raw.githubusercontent.com/nukc/ApkMultiChannelPlugin/master/art/choose-apk.png" alt=""></p>
</li>
<li><p>配置</p>
<p>配置签名信息，打包方式和渠道等<br><img src="https://raw.githubusercontent.com/nukc/ApkMultiChannelPlugin/master/art/setting.png" alt=""></p>
<p>配置说明：</p>
<p>Key Store Path: 签名文件的路径</p>
<p>Key Store Password: 签名文件的密码</p>
<p>Key Alias: 密钥别名</p>
<p>Key Password: 密钥密码 </p>
<p>Zipalign Path: zipalign文件的路径（用于优化 apk；zipalign 可以确保所有未压缩的数据均是以相对于文件开始部分的特定字节对齐开始，这样可减少应用消耗的 RAM 量。）</p>
<p>Signer Version: 选择签名版本：apksigner 和 jarsigner </p>
<p>Build Type: 打包方式 </p>
<p>Channels: 渠道列表，每行一个，最前面可加 &gt; 或不加（保存信息的时候，程序会自行加上）</p>
</li>
<li><p>开始打包</p>
<p>配置完成之后按 OK 就会开始进行渠道打包，文件会输出在选中的apk的当前目录下的channels目录中<br><img src="https://raw.githubusercontent.com/nukc/ApkMultiChannelPlugin/master/art/output.png" alt=""></p>
</li>
</ol>
<h1 id="61-CodeMaker"><a href="#61-CodeMaker" class="headerlink" title="61.CodeMaker"></a>61.<a href="https://github.com/x-hansong/CodeMaker" target="_blank" rel="external">CodeMaker</a></h1><p>一个 IDEA 的代码生成插件，通过 Velocity 支持自定义代码模板来生成代码。详细介绍<a href="http://blog.xiaohansong.com/2017/02/03/codemaker/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="external">IDEA代码生成插件CodeMaker</a></p>
<p><img src="http://7xjtfr.com1.z0.glb.clouddn.com/codemaker.gif" alt=""></p>
<h1 id="62-adb-idea"><a href="#62-adb-idea" class="headerlink" title="62.adb-idea"></a>62.<a href="https://github.com/pbreault/adb-idea" target="_blank" rel="external">adb-idea</a></h1><p>可以一键清理缓存并重启APP</p>
<p><img src="https://github.com/pbreault/adb-idea/raw/master/website/find_actions.png" alt=""></p>
<p>此插件来自zhoutianling@ltbl.cn的分享，感谢<a href="">zhoutianling@ltbl.cn</a>的分享</p>
<h1 id="63-JVM-Debugger-Memory-View"><a href="#63-JVM-Debugger-Memory-View" class="headerlink" title="63.JVM Debugger Memory View"></a>63.<a href="https://blog.jetbrains.com/idea/2016/08/jvm-debugger-memory-view-for-intellij-idea/" target="_blank" rel="external">JVM Debugger Memory View</a></h1><p>Android Studio和IDEA中一个很有用的内存调试插件</p>
<p>详细可参考<a href="https://zhuanlan.zhihu.com/p/25110433" target="_blank" rel="external">说一说Android Studio和IDEA中一个很有用的内存调试插件</a>一文。</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/2/6/69aa3f002477b228bf49b2478fce1d2b" alt=""></p>
<h1 id="64-TinyPic"><a href="#64-TinyPic" class="headerlink" title="64.TinyPic"></a>64.<a href="https://github.com/shenjiajun53/TinyPic" target="_blank" rel="external">TinyPic</a></h1><p>功能：压缩图片资源，一次最多压缩500张 压缩的核心功能是TinyPng这个网站提供的</p>
<p><a href="https://tinypng.com/" target="_blank" rel="external">https://tinypng.com/</a></p>
<p>但是这个网站一次只能上传20张图片，所以你需要上传下载，上传下载重复工作。 好在这个网站提供了api可以压缩图片。</p>
<p>在开发者页面下申请api key。对于一个key，每月有500次的免费压缩额度，如果压缩超过了 500张图片，就不能使用了。需要另外付费。但是申请这个api特别简单，填下邮箱，用户名就行，多申请 两个邮箱。1000张图片也妥妥够了。 这里推荐google个十分钟邮箱，不需要注册，只能使用十分钟，用来收一下验证码很方便。</p>
<p><strong>使用方式：</strong><br>1.在File-&gt;Settings-&gt;Plugins里下载插件 TinyPic</p>
<p>2.安装完后重启，在Tools目录下找到TinyPic</p>
<p><img src="https://github.com/shenjiajun53/TinyPic/raw/master/screenshots/location.png" alt=""></p>
<p>3.输入在 <a href="https://tinypng.com/developers" target="_blank" rel="external">https://tinypng.com/developers</a> 申请的api key</p>
<p><img src="https://github.com/shenjiajun53/TinyPic/raw/master/screenshots/input_key.png" alt=""></p>
<p>4.选择图片，可以选择图片，或者选择文件夹或者同时选中，反正是遍历文件夹下的图片，筛选jpg和png ，key的剩余次数</p>
<p><img src="https://github.com/shenjiajun53/TinyPic/raw/master/screenshots/select_images.png" alt=""></p>
<p>5.压缩进度<br><img src="https://github.com/shenjiajun53/TinyPic/raw/master/screenshots/progress.png" alt=""></p>
<p>6.超过500次的提示（后续会考虑加入 生成压缩的信息的文件，因为大家都用git，其实也不是很必要）</p>
<p><img src="https://github.com/shenjiajun53/TinyPic/raw/master/screenshots/warning.png" alt=""></p>
<h1 id="65-ReciteWords"><a href="#65-ReciteWords" class="headerlink" title="65.ReciteWords"></a>65.<a href="https://github.com/BolexLiu/ReciteWords" target="_blank" rel="external">ReciteWords</a></h1><p>这是一个androidStudio翻译与陌生单词记录插件</p>
<p><img src="https://github.com/BolexLiu/ReciteWords/raw/master/img/1.png" alt=""></p>
<p>你所翻译的单词会被记录在你当前用户目录下的ReciteWords.md文件中（如:C:\Users\Bolex\ReciteWords.md）。可以通过Markdown编辑器打开它进行学习。效果如下:<br><img src="https://github.com/BolexLiu/ReciteWords/raw/master/img/2.png" alt=""></p>
<h1 id="66-TemplateBuilder"><a href="#66-TemplateBuilder" class="headerlink" title="66.TemplateBuilder"></a>66.<a href="https://puke3615.github.io/2017/03/06/TemplateBuilder[Chinese]/" target="_blank" rel="external">TemplateBuilder</a></h1><p>TemplateBuilder是一款能够帮助我们快速生成Android Studio Template的AS插件，将通过逐个文件去配置模板的方式改进为通过插件来实现，对于简单的模板制作，只需要一键即可生成。</p>
<p><img src="https://puke3615.github.io/2017/03/06/TemplateBuilder[Chinese]/img1.png" alt=""></p>
<p>具体使用请参考<a href="https://puke3615.github.io/2017/03/06/TemplateBuilder[Chinese]/" target="_blank" rel="external">TemplateBuilder(中文版)](TemplateBuilder</a></p>
<h1 id="67-intellij-java2smali"><a href="#67-intellij-java2smali" class="headerlink" title="67.intellij-java2smali"></a>67.<a href="https://github.com/ollide/intellij-java2smali" target="_blank" rel="external">intellij-java2smali</a></h1><p>将Java &amp; Kotlin编译成smali</p>
<p><img src="https://github.com/ollide/intellij-java2smali/raw/master/img/plugin_usage2.gif" alt=""></p>
<h1 id="68-innerbuilder"><a href="#68-innerbuilder" class="headerlink" title="68.innerbuilder"></a>68.<a href="https://github.com/analytically/innerbuilder" target="_blank" rel="external">innerbuilder</a></h1><p>InnerBuilder 一款Intellj IDEA 和Android Studio自动生成内部类Builder代码的插件。</p>
<p><img src="https://github.com/analytically/innerbuilder/raw/master/screenshot.png" alt=""></p>
<h1 id="69-Statistic"><a href="#69-Statistic" class="headerlink" title="69.Statistic"></a>69.<a href="https://plugins.jetbrains.com/plugin/4509-statistic" target="_blank" rel="external">Statistic</a></h1><p>统计代码行数</p>
<p><img src="https://plugins.jetbrains.com/files/4509/screenshot_16675.png" alt=""></p>
<p>使用可参考:<a href="http://blog.csdn.net/dreamlivemeng/article/details/67637789" target="_blank" rel="external">Android studio插件Statistic的使用</a></p>
<h1 id="70-create-intent-inspection"><a href="#70-create-intent-inspection" class="headerlink" title="70.create-intent-inspection"></a>70.<a href="https://github.com/shiraji/create-intent-inspection" target="_blank" rel="external">create-intent-inspection</a></h1><p>创建intent</p>
<p><img src="https://github.com/shiraji/create-intent-inspection/raw/master/website/images/create_intent_inspection_screen_shot.gif" alt=""></p>
<h1 id="71-color-manager"><a href="#71-color-manager" class="headerlink" title="71.color-manager"></a>71.<a href="https://github.com/shiraji/color-manager" target="_blank" rel="external">color-manager</a></h1><p>颜色管理</p>
<p><img src="https://github.com/shiraji/color-manager/raw/master/website/images/normal.png" alt=""></p>
<h1 id="72-new-instance-inspection"><a href="#72-new-instance-inspection" class="headerlink" title="72.new-instance-inspection"></a>72.<a href="https://github.com/shiraji/new-instance-inspection" target="_blank" rel="external">new-instance-inspection</a></h1><p>创建fragment实例</p>
<p><img src="https://github.com/shiraji/new-instance-inspection/raw/master/website/images/new_instance_inspection_screenshot.gif" alt=""></p>
<h1 id="73-Exynap"><a href="#73-Exynap" class="headerlink" title="73.Exynap"></a>73.<a href="http://exynap.com/" target="_blank" rel="external">Exynap</a></h1><p>exynap是一个可以帮助你查找并实现您需要的代码的插件</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1621204-98d39b22737a8728.gif?imageMogr2/auto-orient/strip" alt=""></p>
<h1 id="74-databinding-support"><a href="#74-databinding-support" class="headerlink" title="74.databinding-support"></a>74.<a href="https://github.com/shiraji/databinding-support" target="_blank" rel="external">databinding-support</a></h1><p>一个可以快速实现databinding的插件</p>
<p><img src="https://raw.githubusercontent.com/shiraji/databinding-support/master/websites/images/wrap.gif" alt=""></p>
<h1 id="75-pomodoro-tm"><a href="#75-pomodoro-tm" class="headerlink" title="75.pomodoro-tm"></a>75.<a href="https://github.com/dkandalov/pomodoro-tm" target="_blank" rel="external">pomodoro-tm</a></h1><p>番茄工作法的 Android Studio / IDEA 插件</p>
<p><img src="https://raw.githubusercontent.com/dkandalov/pomodoro-tm/master/widget.png" alt=""></p>
<h1 id="76-freeline"><a href="#76-freeline" class="headerlink" title="76.freeline"></a>76.<a href="https://github.com/alibaba/freeline" target="_blank" rel="external">freeline</a></h1><p>Freeline 是 Android 平台上的秒级编译方案，Instant Run 的替代品</p>
<p><img src="https://camo.githubusercontent.com/8c2cd6b22e85207884dc843cb9a0b758e636953c/687474703a2f2f7777342e73696e61696d672e636e2f6c617267652f3635653466316536677731663832656b6e616575646a3230746b30316f6d78652e6a7067" alt=""></p>
<h1 id="77-svgtoandroid"><a href="#77-svgtoandroid" class="headerlink" title="77.svgtoandroid"></a>77.<a href="https://github.com/misakuo/svgtoandroid" target="_blank" rel="external">svgtoandroid</a></h1><p>Intellij Platform插件，通过其可以完成从svg文件到Android VectorDrawable的自动化转换</p>
<p><img src="https://raw.githubusercontent.com/misakuo/svgtoandroid/master/imgs/1.png" alt=""></p>
<h1 id="78-instapk-studio-plugin"><a href="#78-instapk-studio-plugin" class="headerlink" title="78.instapk-studio-plugin"></a>78.<a href="https://github.com/PytenLabs/instapk-studio-plugin" target="_blank" rel="external">instapk-studio-plugin</a></h1><p>分享apk文件</p>
<p><img src="https://github.com/PytenLabs/instapk-studio-plugin/raw/master/images/install.gif" alt=""></p>
<h1 id="79-here-be-dragons"><a href="#79-here-be-dragons" class="headerlink" title="79.here-be-dragons"></a>79.<a href="https://github.com/anupcowkur/here-be-dragons" target="_blank" rel="external">here-be-dragons</a></h1><p>加上@SideEffect注解的方法,在调用的地方会出现一只鸟</p>
<p><img src="https://github.com/anupcowkur/here-be-dragons/raw/master/here-be-dragons.gif" alt=""></p>
<h1 id="80-android-studio-proteus-plugin"><a href="#80-android-studio-proteus-plugin" class="headerlink" title="80.android-studio-proteus-plugin"></a>80.<a href="https://github.com/flipkart-incubator/android-studio-proteus-plugin" target="_blank" rel="external">android-studio-proteus-plugin</a></h1><p>将xml转化为json</p>
<h1 id="最后：推荐梯子：-Github上的star数13000"><a href="#最后：推荐梯子：-Github上的star数13000" class="headerlink" title="*最后：推荐梯子：(Github上的star数13000+)"></a>*最后：推荐梯子：(Github上的star数13000+)</h1><p><a href="https://github.com/XX-net/XX-Net" target="_blank" rel="external">XX-Net</a><br>具体使用请参考里面文档已经写得很清楚了，按照文档一步步操作即可。关键是免费的！免费的！免费的！速度也快！</p>
<p>本文也可以访问<a href="http://www.jianshu.com/p/c76b0d8a642d" target="_blank" rel="external">简书</a>内容是一样的</p>
<p>本文会持续更新（如果发现有好玩，好用的插件，欢迎通过Email:<a href="">ydmmocoo@gmail.com</a>告诉我），请持续关注。哈哈！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/24/Android自定义加载中Dialog/" itemprop="url">
                  Android自定义加载中Dialog
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-24T15:57:29+08:00" content="2016-06-24">
              2016-06-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android开发/" itemprop="url" rel="index">
                    <span itemprop="name">Android开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/24/Android自定义加载中Dialog/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/24/Android自定义加载中Dialog/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>开发中经常需要请求网络获取数据，我们在请求网络到得到数据时当中需要等待一些时间，为了增加用户体验，我们一般会用一个Dialog来提示用户我们在加载网络数据。今天我们来实现如下效果的加载中Dialog。<br><img src="http://7xvlr6.com1.z0.glb.clouddn.com/QQ%E5%9B%BE%E7%89%8720160624155145.jpg" alt=""></p>
<p>从图中我们可以看到要这个Dialog是图片还有文字组成的，(不过我这里使用代码实现的，没有用图片)，以下是这个加载图形的代码：</p>
<pre><code>public class LVCircularRing extends View {

private float mWidth = 0f;
private float mPadding = 0f;
private float startAngle = 0f;
private Paint mPaint;

public LVCircularRing(Context context) {
    this(context, null);
}

public LVCircularRing(Context context, AttributeSet attrs) {
    this(context, attrs, 0);
}

public LVCircularRing(Context context, AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);
    initPaint();
}

@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);

    if (getMeasuredWidth() &gt; getHeight())
        mWidth = getMeasuredHeight();
    else
        mWidth = getMeasuredWidth();
    mPadding = 5;
}

@Override
protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);

    mPaint.setColor(Color.argb(100, 255, 255, 255));
    canvas.drawCircle(mWidth / 2, mWidth / 2, mWidth / 2 - mPadding, mPaint);
    mPaint.setColor(Color.WHITE);
    RectF rectF = new RectF(mPadding, mPadding, mWidth - mPadding, mWidth - mPadding);
    canvas.drawArc(rectF, startAngle, 100
            , false, mPaint);//第四个参数是否显示半径

}


private void initPaint() {
    mPaint = new Paint();
    mPaint.setAntiAlias(true);
    mPaint.setStyle(Paint.Style.STROKE);
    mPaint.setColor(Color.WHITE);
    mPaint.setStrokeWidth(8);
}

public void startAnim() {
    stopAnim();
    startViewAnim(0f, 1f, 1000);
}

public void stopAnim() {
    if (valueAnimator != null) {
        clearAnimation();
        valueAnimator.setRepeatCount(1);
        valueAnimator.cancel();
        valueAnimator.end();
    }
}

ValueAnimator valueAnimator;

private ValueAnimator startViewAnim(float startF, final float endF, long time) {
    valueAnimator = ValueAnimator.ofFloat(startF, endF);

    valueAnimator.setDuration(time);
    valueAnimator.setInterpolator(new LinearInterpolator());
    valueAnimator.setRepeatCount(ValueAnimator.INFINITE);//无限循环
    valueAnimator.setRepeatMode(ValueAnimator.RESTART);//

    valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
        @Override
        public void onAnimationUpdate(ValueAnimator valueAnimator) {

            float value = (float) valueAnimator.getAnimatedValue();
            startAngle = 360 * value;

            invalidate();
        }
    });
    valueAnimator.addListener(new AnimatorListenerAdapter() {
        @Override
        public void onAnimationEnd(Animator animation) {
            super.onAnimationEnd(animation);
        }
    });
    if (!valueAnimator.isRunning()) {
        valueAnimator.start();
    }

    return valueAnimator;
}
}
</code></pre><p>Dialog代码：</p>
<pre><code>public class LoadingDialog {
LVCircularRing mLoadingView;
Dialog mLoadingDialog;

public LoadingDialog(Context context,String msg) {
    // 首先得到整个View
    View view = LayoutInflater.from(context).inflate(
            R.layout.loading_dialog_view, null);
    // 获取整个布局
    LinearLayout layout = (LinearLayout) view.findViewById(R.id.dialog_view);
    // 页面中的LoadingView
    mLoadingView = (LVCircularRing) view.findViewById(R.id.lv_circularring);
    // 页面中显示文本
    TextView loadingText = (TextView) view.findViewById(R.id.loading_text);
    // 显示文本
    loadingText.setText(msg);
    // 创建自定义样式的Dialog
    mLoadingDialog = new Dialog(context, R.style.loading_dialog);
    // 设置返回键无效
    mLoadingDialog.setCancelable(false);
    mLoadingDialog.setContentView(layout, new LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.MATCH_PARENT));
}

public void show(){
    mLoadingDialog.show();
    mLoadingView.startAnim();
}

public void close(){
    if (mLoadingDialog!=null) {
        mLoadingView.stopAnim();
        mLoadingDialog.dismiss();
        mLoadingDialog=null;
    }
}
}
</code></pre><p>布局文件loading_dialog_view代码：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout
xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:id=&quot;@+id/dialog_view&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;
android:gravity=&quot;center&quot;
android:background=&quot;@drawable/dialog_bg&quot;
android:padding=&quot;20dp&quot;
android:orientation=&quot;vertical&quot;&gt;

&lt;com.ye.daqiapp.ui.widget.loading.LVCircularRing
    android:id=&quot;@+id/lv_circularring&quot;
    android:layout_width=&quot;50dp&quot;
    android:layout_height=&quot;50dp&quot;/&gt;

&lt;TextView
    android:id=&quot;@+id/loading_text&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:textColor=&quot;#ffffff&quot;
    android:layout_marginTop=&quot;5dp&quot;
    android:textSize=&quot;15sp&quot;/&gt;

&lt;/LinearLayout&gt;
</code></pre><p>Dialog中Style代码：</p>
<pre><code>&lt;style name=&quot;loading_dialog&quot; parent=&quot;android:style/Theme.Dialog&quot;&gt;
    &lt;item name=&quot;android:windowFrame&quot;&gt;@null&lt;/item&gt;
    &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt;
    &lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/transparent&lt;/item&gt;
    &lt;item name=&quot;android:windowIsFloating&quot;&gt;true&lt;/item&gt;
    &lt;item name=&quot;android:backgroundDimEnabled&quot;&gt;false&lt;/item&gt;
    &lt;item name=&quot;android:windowContentOverlay&quot;&gt;@null&lt;/item&gt;
&lt;/style&gt;
</code></pre><p>背景dialog_bg代码</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
&lt;!-- 内部颜色 --&gt;
&lt;solid android:color=&quot;#444444&quot; /&gt;

&lt;!-- 圆角的幅度 --&gt;
&lt;corners
    android:bottomLeftRadius=&quot;3dp&quot;
    android:bottomRightRadius=&quot;3dp&quot;
    android:topLeftRadius=&quot;3dp&quot;
    android:topRightRadius=&quot;3dp&quot; /&gt;
&lt;/shape&gt;
</code></pre><p>如何使用：<br>在需要使用的地方初始化Dialog:</p>
<pre><code>LoadingDialog dialog=new LoadingDialog(context,&quot;玩命加载中...&quot;);
//显示Dialog
dialog.show();
//关闭Dialog
dialog.close();
</code></pre><p>附上一些加载动画地址：<br><a href="https://github.com/ldoublem/LoadingView" target="_blank" rel="external">LoadingView</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/22/Android面试题整理/" itemprop="url">
                  Android面试题整理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-22T16:14:54+08:00" content="2016-06-22">
              2016-06-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android开发/" itemprop="url" rel="index">
                    <span itemprop="name">Android开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/22/Android面试题整理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/22/Android面试题整理/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java部分"><a href="#Java部分" class="headerlink" title="Java部分"></a>Java部分</h2><p>1.GC是什么? 为什么要有GC?</p>
<blockquote>
<p>GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java   提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。</p>
</blockquote>
<p>2.XML包括哪些解释技术，区别是什么？</p>
<blockquote>
<p>DOM和SAX<br>  DOM将文档解析成一颗文档树，可在节点上进行遍历、增加、修改和删除。一次性读入内存，对内存消耗大。<br>  SAX至上而下解析文档，以事件进行驱动。不会一次性读入内存，对内存消耗小，不能任意读取节点，并且不能对节点进行增加、修改和删除。</p>
</blockquote>
<p>3.switch语句能否作用在byte上，能否作用在long上，能否作用在String上?</p>
<blockquote>
<p>switch能作用在byte、char、short和int上，JDK1.7后可以作用在String上。</p>
</blockquote>
<p>4.”==”和equals方法究竟有什么区别？</p>
<blockquote>
<p>==和equals都可以比较地址。==是运算符，equals是方法，方法可以通过重写改变其行为，如String的equals就是比较字符串内容。</p>
</blockquote>
<p>5.构造方法能否被重写和重载？</p>
<blockquote>
<p>构造方法不能被重写但是能被重载。</p>
</blockquote>
<p>6.面向对象的特征有哪些？</p>
<blockquote>
<p>封装、继承、多态和抽象。</p>
</blockquote>
<p>7.抽象类和接口的区别？</p>
<blockquote>
<p>1).抽象类是abstract class修饰，接口是interface修饰。<br>  2).抽象类可以有任意类型的属性，接口只能有静态常量修饰的属性。<br>  3).抽象类可以有普通方法和抽象法方法，接口的方法都是抽象方法。<br>  4).抽象类和接口都不能实例化，但是抽象类有构造方法，接口没有构造方法。<br>  5).抽象类只能单根继承，接口可以多重实现。</p>
</blockquote>
<p>8.内部类可以引用它的包含类的成员吗？有没有什么限制？ </p>
<blockquote>
<p>可以引用。如果需要指定当前类时要用外部类.this来引用。如果引用局部变量，需要将局部变量指定为final。</p>
</blockquote>
<p>9.String s = new String(“xyz”);创建了几个String Object? 二者之间有什么区别？</p>
<blockquote>
<p>2个对象。”xyz”创建在字符串常量池中，new String()创建在堆中。</p>
</blockquote>
<p>10.try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后? </p>
<blockquote>
<p>会在return前执行。</p>
</blockquote>
<p>11.Integer与int的区别</p>
<blockquote>
<p>Integer为包装类，int是基本数据类型。包装类拥有方法和属性，基本数据类型不具备。包装类可以通过intValue来转换成基本数据类型，也可以通过new     Integer()将基本数据类型转换为包装类。在JDK1.5后，包装类和基本数据类型可以实现自动转换。</p>
</blockquote>
<p>12.sleep()和wait()有什么区别?</p>
<blockquote>
<p>sleep是Thread类的方法，wait是Object类的方法。<br>  sleep是自动唤醒，wait需要其他线程来唤醒。<br>  sleep不会释放同步锁，wait会释放同步锁。<br>  sleep可以用在任意方法中，wait只能用在同步方法或同步块中。<br>  Sleep（）不会释放对象锁到时自动恢复， wait（）会释放对象锁 进入等待此对象的等待锁定池 发出notify（）方法后 才进入等待锁定池准备对象锁的获   取进入运行状态</p>
</blockquote>
<p>13.同步和异步有何异同，在什么情况下分别使用他们？</p>
<blockquote>
<p>同步指同一时间只能一个线程执行该方法，其他线程需要等待。异步指多个线程可以同时执行某个方法，并共享同一资源。<br>  同步可以让访问的资源具有安全性，因为同一时间只能一个线程对其进行访问。但是效率不高。<br>  异步对访问的资源会造成不稳定性，比如多个线程同时访问一个资源，一个在修改、一个在删除、一个在读取，这样可能会造成资源的混乱。但是由于同时运行，   执行效率得到提高。</p>
</blockquote>
<p>14.启动一个线程是用run()还是start()? </p>
<blockquote>
<p>start()方法启动线程，run方法是线程执行的主方法。</p>
</blockquote>
<p>15.java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？</p>
<blockquote>
<p>java中有三种流，分别是字节流（InputStream、OutputStream）、字符流（Reader、Writer）、对象流（ObjectInputStream、    ObjectOutputStream）。</p>
</blockquote>
<p>16.字节流与字符流的区别？</p>
<blockquote>
<p>字节流用于读取或写出二进制数据，比如图片、影像等数据。<br>  字符流用于读取或写出字符数据，比如传输字符串。<br>  所有的数据都可以通过字节流来进行处理，不过如果是字符数据，用字节流还需要进行转换后传输，如果使用字符流可以方便数据的转换。</p>
</blockquote>
<p>17.error和exception有什么区别?</p>
<blockquote>
<p>error是系统错误，代码不能处理的错误，比如内存溢出、堆栈溢出等。<br>  exception是程序异常，可以通过代码try-catch进行处理，比如空指针异常，数组越界等。</p>
</blockquote>
<p>18.谈谈final,finally,finalize的区别？</p>
<blockquote>
<p>final是修饰符，可以修饰类（不能被继承）、属性（常量）、和方法（不能被重写）。<br>  finally是异常处理块中的代码块，表示无论如何都会执行的代码块。<br>  finalize是Object类的方法，该方法在对象被垃圾回收之前执行的方法。</p>
</blockquote>
<p>19.当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?</p>
<blockquote>
<p>如果其他方法没有加synchronized的话是可以进入的。</p>
</blockquote>
<p>20.当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?</p>
<blockquote>
<p>java中只有值传递，如果传递的对象，实际也是传递该对象的地址。</p>
</blockquote>
<p>21.作用域public,private,protected,以及不写时的区别</p>
<blockquote>
<p>public公共修饰符，表示任意类都可以访问。<br>  protected为受保护的修饰符，表示同类、同包以及不同包但是父子关系的是可以访问。<br>  不写表示默认修饰符，或者称为package修饰符，该修饰符表示只有同类或同包下的类可以访问，出了这个包就不能访问了。<br>  private为私有修饰符，表示只有同类中可以访问，出了这个类就不能访问了。</p>
</blockquote>
<p>22.用最有效率的方法算出2乘以8等於几 2《 3</p>
<blockquote>
<p>将2的二进制向左移3位。java中用&lt;&lt;来移位。</p>
</blockquote>
<p>23.heap和stack有什么区别。</p>
<blockquote>
<p>heap表示堆，stack表示栈。堆中放对象，栈中放引用变量。<br>  堆空间是一个无序的空间，栈是先进后出的结构。</p>
</blockquote>
<p>24.运行时异常与一般异常有何异</p>
<blockquote>
<p>运行时异常是指继承于RuntimeException的异常，这些异常在编译时可以不进行处理，当运行时如果出现问题才会抛出。如NullPointException、        ArrayIndexOutOfBoundsException<br>  一般异常也称为编译时异常，这些异常是继承Exception但又不属于RuntimeException的子类，如果程序中出现这些异常，在编译时必须进行捕获或抛出，否   则编译无法通过。如IOException、FileNotFoundException</p>
</blockquote>
<p>25.垃圾回收的优点和原理。并考虑2种回收机制</p>
<blockquote>
<p>Java语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存   管理。由于有个垃圾回收机制，Java中的对象不再有”作用域”的概念，只有对象的引用才有”作用域”。垃圾回收可以有效的防止内存泄露，有效的使用可以使用   的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，程序员不能   实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。</p>
</blockquote>
<p>26.描述一下JVM加载class文件的原理机制?</p>
<blockquote>
<p>JVM中类的装载是由ClassLoader和它的子类来实现的,Java ClassLoader 是一个重要的Java运行时系统组件。它负责在运行时查找和装入类文件的类。</p>
</blockquote>
<p>27.是否可以从一个static方法内部发出对非static方法的调用？</p>
<blockquote>
<p>不能，除非先创建非static方法所在类的对象。</p>
</blockquote>
<p>28.什么是java序列化，如何实现java序列化？</p>
<blockquote>
<p>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序   列化是为了解决在对对象流进行读写操作时所引发的问题。<br>  序列化的实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化    的，然后使用一个输出流(如：FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream对象的   writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流。</p>
</blockquote>
<p>29.Anonymous Inner Class(匿名内部类)是否可以extends(继承)其它类，是否可以implements(实现)interface(接口)？</p>
<blockquote>
<p>匿名内部类可以继承类或实现接口，但不是显示的使用extends或implements来继承或实现。</p>
</blockquote>
<p>30.ArrayList和Vector的区别,HashMap和Hashtable的区别？</p>
<blockquote>
<p>ArrayList是JDK1.2的集合类并且线程不安全，Vector是1.0的集合类并且线程安全，二者用法类似。<br>  HashMap线程不安全且能放空键或空值，Hashtable线程安全且不能放空键或空值。</p>
</blockquote>
<p>31.String 和StringBuffer有什么差别？在什么情况下使用它们？</p>
<blockquote>
<p>String字符串的基本类，该字符串是不可变的。StringBuffer是利用堆来存储字符串，并且可以对字符串的内容进行改变。</p>
</blockquote>
<p>32.new一个类对象和使用类名创建一个对象有什么区别？二者使用时应该注意什么？</p>
<blockquote>
<p>new对象是最常见的创建对象的方式，利用类模板是通过反射来创建对象。虽然new对象时在底层也会通过类模板来创建对象，但是new对象的效率要比直接通过类   模板创建对象的方式要高。<br>  但是使用类模板的方式可以让程序的灵活性提高。</p>
</blockquote>
<p>33.LinkedList和ArrayList的区别？</p>
<blockquote>
<p>1）LinkedList是链表结构的集合，ArrayList数组结构的集合。<br>  2）LinkedList在中间或前面增加或删除数据时效率比ArrayList高。<br>  3）LinkedList在最后添加或删除数据时效率比ArrayList低。<br>  4）遍历数据时ArrayList效率高于LinkedList。</p>
</blockquote>
<p>34.介绍JAVA开发中常用的Collection FrameWork（集合框架）?</p>
<blockquote>
<p>Java中集合框架分为Collection和Map接口，Collection接口下的集合每个元素都由一个值组成，Map接口下的集合类每个元素都是由键值对组成。<br>  Collection接口下面有List和Set接口，List接口下常见的类有ArrayList、LinkedList、Vector。它们中的元素可以重复，并且是有序的。Set接口下常   见的类有HashSet、TreeSet。它们中的元素不能重复，并且是无序的。</p>
</blockquote>
<p>35.在异常当中 throw和throws 有什么区别和联系？</p>
<blockquote>
<p>throw是在代码中抛出一个异常，后面跟的是异常对象，虚拟机运行到这里时会立即引发一个异常。<br>  throws是写在方法声明上的，表示声明该方法可能会抛出异常，后面跟的是异常类型。调用该方法的时候可以选择处理它或继续往外抛。</p>
</blockquote>
<p>36.重载和重写的区别</p>
<blockquote>
<p>重载是指在一个类中，两个或两个以上的方法具有相同方法名和不同参数列表，则表示这些方法为重载方法。<br>  重写是指在父类和子类中，子类的方法和父类的方法具有相同方法名、相同参数列表、相同返回类型、子类的访问修饰符范围不小于父类的访问修饰符范围，异常   的类型和个数不大于或多于父类的异常类型和个数，则表示该方法为重写方法。换句话说重载方法是区分同一个类中相同方法名的方法，重写方法是找到父类相同   方法名的方法并重新改变方法的行为。</p>
</blockquote>
<p>37.Java中try catch finally的执行顺序</p>
<blockquote>
<p>先执行try中代码发生异常执行catch中代码，最后一定会执行finally中代码</p>
</blockquote>
<p>38.内存泄露的原因：</p>
<blockquote>
<ul>
<li>资源对象没关闭。<br>如Cursor、File等资源。他们会在finalize中关闭，但这样效率太低。容易造成内存泄露。<br>SQLiteCursor，当数据量大的时候容易泄露</li>
<li>使用Adapter时，没有使用系统缓存的converView。</li>
<li>即时调用recycle（）释放不再使用的Bitmap。<br>适当降低Bitmap的采样率，如：<br>BitmapFactory.Options options = newBitmapFactory.Options();<br>options.inSampleSize = 2;//图片宽高都为原来的二分之一，即图片为原来的四分之一<br>Bitmap bitmap =BitmapFactory.decodeStream(cr.openInputStream(uri), null, options); preview.setImageBitmap(bitmap);</li>
<li>使用application的context来替代activity相关的context。<br>尽量避免activity的context在自己的范围外被使用，这样会导致activity无法释放。</li>
<li>注册没取消造成内存泄露<br>如：广播<br>集合中的对象没清理造成的内存泄露我们通常把一些对象的引用加入到了集合中，当我们不需要该对象时，并没有把它的引用从集合中清理掉，这样这个集合就会   越来越大。如果这个集合是static的话，那情况就更严重了。</li>
<li>Handler应该申明为静态对象， 并在其内部类中保存一个对外部类的弱引用。如下：<br>static class MyHandler extends Handler<br>{<pre><code> WeakReference&lt;Activity &gt; mActivityReference;
 MyHandler(Activity activity)
{ 
      mActivityReference= new WeakReference&lt;Activity&gt;(activity);
}
</code></pre>   @Override<br>   public void handleMessage(Message msg)<br>  {<pre><code> final Activity activity = mActivityReference.get();
 if (activity != null)
{
       mImageView.setImageBitmap(mBitmap);
}    
</code></pre>   }<br>}</li>
</ul>
</blockquote>
<p>39.Iterator和Enumeration的不同</p>
<blockquote>
<ul>
<li>函数接口不同<br>Enumeration只有2个函数接口。通过Enumeration，我们只能读取集合的数据，而不能对数据进行修改。 Iterator只有3个函数接口。Iterator除了能读   取集合的数据之外，也能数据进行删除操作。</li>
<li>Iterator支持fail-fast机制，而Enumeration不支持。 Enumeration 是JDK 1.0添加的接口。使用到它的函数包括Vector、Hashtable等类，这些类   都是JDK 1.0中加入的，Enumeration存在的目的就是为它们提供遍历接口。Enumeration本身并没有支持同步，而在Vector、Hashtable实现   Enumeration时，添加了同步。而Iterator 是JDK 1.2才添加的接口，它也是为了HashMap、ArrayList等集合提供遍历接口。<br>Iterator是支持fail-fast  机制的：当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。<br>ail-fast 机制是java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。例如：当某一个线   程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异   常，产生fail-fast事件。</li>
</ul>
</blockquote>
<p>40.接口的注意点</p>
<blockquote>
<ul>
<li>接口中的字段全部默认为 public static类型。</li>
<li>接口中的方法全部默认为 public类型。</li>
<li>接口中可以申明内部类，而默认为public static，正因为是static，只是命名空间属于接口，代码逻辑不属于接口。所以不违法接口定义。</li>
<li>接口本身可以申明为public或者缺省。</li>
<li>抽象类继承自某接口。如果在抽象类中实现了父类（接口）中的方法，在其子类可以不用实现，否则在子类必须实现。</li>
</ul>
</blockquote>
<p>41.final方法</p>
<blockquote>
<p>将方法声明为final那有两个原因，第一就是说明你已经知道这个方法提供的功能已经满足你要求，不需要进行扩展，并且也不允许任何从此类继承的类来覆写这个方法，但是继承仍然可以继承这个方法，也就是说可以直接使用。第二就是允许编译器将所有对此方法的调用转化为inline调用的机制，它会使你在调用final方法时，直接将方法主体插入到调用处，而不是进行例行的方法调用，例如保存断点，压栈等，这样可能会使你的程序效率有所提高，然而当你的方法主体非常庞大时，或你在多处调用此方法，那么你的调用主体代码便会迅速膨胀，可能反而会影响效率，所以你要慎用final进行方法定义。</p>
</blockquote>
<h2 id="ANDROID部分"><a href="#ANDROID部分" class="headerlink" title="ANDROID部分"></a>ANDROID部分</h2><p>1.activity、Service、BroadcastReceiver的作用（android）</p>
<blockquote>
<p>Activity：Activity是Android程序与用户交互的窗口，是Android构造块中最基本的一种，它需要为保持各界面的状态，做很多持久化的事情，妥善管理生命周期以及一些跳转逻辑<br>service：后台服务于Activity，封装有一个完整的功能逻辑实现，接受上层指令，完成相关的指令，定义好需要接受的Intent提供同步和异步的接口<br>BroadCast Receiver：接受一种或者多种Intent作触发事件，接受相关消息，做一些简单处理，转换成一条Notification，统一了Android的事件广播模型</p>
</blockquote>
<p>2.描述一个完整的Android activity lifecycle</p>
<blockquote>
<p>activity的生命周期方法有：onCreate()、onStart()、onReStart()、onResume()、onPause()、onStop()、onDestory()；</p>
</blockquote>
<p>3.显式intent和隐式intent的区别是什么（android）</p>
<blockquote>
<p>Intent定义：Intent是一种在不同组件之间传递的请求消息，是应用程序发出的请求和意图。作为一个完整的消息传递机制，Intent不仅需要发送端，还需要接收端。<br>显式Intent定义：对于明确指出了目标组件名称的Intent，我们称之为显式Intent。<br>隐式Intent定义：对于没有明确指出目标组件名称的Intent，则称之为隐式Intent。<br>说明：Android系统使用IntentFilter 来寻找与隐式Intent相关的对象。</p>
</blockquote>
<p>4.Android中线程同步的方法</p>
<blockquote>
<p>线程同步的方法可以采用同步方法和同步块。</p>
</blockquote>
<p>5.怎么将一个Activity封装成对话框的样子? 怎样将Activity封装成长按Menu菜单的样子？</p>
<blockquote>
<p>简单你只需要设置 一下Activity的主题就可以了在AndroidManifest.xml 中定义 Activity的地方一句话：<br>Xml代码<br>android :theme=”@android:style/Theme.Dialog”<br>android:theme=”@android:style/Theme.Dialog”<br>这就使你的应用程序变成对话框的形式弹出来了，或者<br>Xml代码<br>android:theme=”@android:style/Theme.Translucent”<br>android:theme=”@android:style/Theme.Translucent”<br>就变成半透明的。<br>重写OnCreateOptionMenu方法来处理按下menu后的行为，然后再该方法中弹出对话框形式的Activity。<br>也可以利用事件监听来监听menu按键，并在该按钮按下后弹出对话框形式的Activity。</p>
</blockquote>
<p>6.介绍一下Android系统的体系结构</p>
<blockquote>
<p>应用层：android的应用程序通常涉及用户界面和交互。<br>应用框架层：UI组件、各种管理器等。<br>函数库层：系统C库、媒体库、webkit、SQLite等。<br>linux核心库：linux系统运行的组件。</p>
</blockquote>
<p>7.描述下横竖屏切换时候 activity 的生命周期</p>
<blockquote>
<p>不设置Activity的android:configChanges时,切屏会重新调用各个生命周期,切横屏时会执行一次,切竖屏时会执行两次.<br>设置Activity的android:configChanges=”orientation”时,切屏还是会重新调用各个生命周期,切横、竖屏时只会执行一次.<br>设置Activity的android:configChanges=”orientation|keyboardHidden”时,切屏不会重新调用各个生命周期,只会执行onConfigurationChanged方法.</p>
</blockquote>
<p>8.android 中的动画有哪几种，它们的特点和区别是什么 ?</p>
<blockquote>
<p>两种，一种是补间动画（Tween）动画、还有一种是帧动画（Frame）动画。Tween动画，这种实现方式可以使视图组件移动、放大、缩小以及产生透明度的变化;另一种Frame动画，传统的动画方法，通过顺序的播放排列好的图片来实现，类似电影。</p>
</blockquote>
<p>9.一条最长的短信息约占多少 byte?</p>
<blockquote>
<p>140byte，70个汉字。</p>
</blockquote>
<p>10.描述handler 机制的原理</p>
<blockquote>
<p>andriod提供了 Handler 和 Looper 来满足线程间的通信。<br>Handler 先进先出原则。<br>Looper类用来管理特定线程内对象之间的消息交换(Message Exchange)。<br>1)Looper: 一个线程可以产生一个Looper对象，由它来管理此线程里的Message Queue(消息队列)。<br>2)Handler: 你可以构造Handler对象来与Looper沟通，以便push新消息到Message Queue里;或者接收Looper从Message Queue取出)所送来的消息。<br>3) Message Queue(消息队列):用来存放线程放入的消息。<br>4)线程：UI thread 通常就是main thread，而Android启动程序时会替它建立一个Message Queue。</p>
</blockquote>
<p>11.如何将 SQLite 数据库 (dictionary.db 文件 ) 与 apk 文件一起发布 ?</p>
<blockquote>
<p>可以将dictionary.db文件复制到Eclipse Android工程中的res\raw目录中。所有在res\raw目录中的文件不会被压缩，这样可以直接提取该目录中的文件。<br>使用openDatabase方法来打开数据库文件，如果该文件不存在，系统会自动创建/sdcard/dictionary目录，并将res\raw目录中的 dictionary.db文件复制到/sdcard/dictionary目录中</p>
</blockquote>
<p>12.说说 android 中 mvc 的具体体现</p>
<blockquote>
<p>mvc是model,view,controller的缩写，mvc包含三个部分：<br>模型（model）对象：是应用程序的主体部分，所有的业务逻辑都应该写在该层。<br>视图（view）对象：是应用程序中负责生成用户界面的部分。也是在整个mvc架构中用户唯一可以看到的一层，接收用户的输入，显示处理结果。<br>控制器（control）对象：是根据用户的输入，控制用户界面数据显示及更新model对象状态的部分，控制器更重要的一种导航功能，响应用户出发的相关事件，交给m层处理。<br>android鼓励弱耦合和组件的重用，在android中mvc的具体体现如下：<br>1)视图（view）：一般采用xml文件进行界面的描述，使用的时候可以非常方便的引入。<br>2)控制层（controller）：android的控制层的重任通常落在了众多的acitvity的肩上，这句话也就暗含了不要在acitivity中写过多的代码，要通过activity交割model业务逻辑层处理，这样做的另外一个原因是android中的acitivity的响应时间是5s，如果耗时的操作放在这里，程序就很容易被回收掉。<br>3)模型层（model）：对数据库的操作、对网络等的操作都应该在model里面处理，当然对业务计算等操作也是必须放在的该层的。</p>
</blockquote>
<p>13.请介绍下 Android 中常用的五种布局</p>
<blockquote>
<p>帧布局（FrameLayout）<br>线性布局(LinearLayout)<br>表格布局(TableLayout)<br>相对布局(RelativeLayout)<br>绝对布局(AbsoluteLayout)</p>
</blockquote>
<p>14.如何启用 Service ，如何停用 Service</p>
<blockquote>
<p>1)startService用于启动Service、stopService停止Service。<br>2)bindService绑定Service，unbindService解除Service的绑定。</p>
</blockquote>
<p>15.如何优化ListView</p>
<blockquote>
<p>1、如果自定义适配器，那么在getView方法中要考虑方法传进来的参数contentView是否为null，如果为null就创建contentView并返回，如果不为null则直接使用。在这个方法中尽可能少创建view。<br>2、给contentView设置tag（setTag（）），传入一个viewHolder对象，用于缓存要显示的数据，可以达到图像数据异步加载的效果。<br>3、如果listview需要显示的item很多，就要考虑分页加载。比如一共要显示100条或者更多的时候，我们可以考虑先加载20条，等用户拉到列表底部的时候再去加载接下来的20条。</p>
</blockquote>
<p>16.描述4 种 activity 的启动模式</p>
<blockquote>
<p>1)standard ：系统的默认模式，一次跳转即会生成一个新的实例。假设有一个activity命名为MainActivity，执行语句：<br>startActivity(new Intent(MainActivity.this, MainActivity.class))后，MainActivity将跳转到另外一个MainActivity，也就是现在的Task栈里面有MainActivity的两个实例。按返回键后你会发现仍然是在MainActivity（第一个）里面。<br>2)singleTop：singleTop 跟standard 模式比较类似。如果已经有一个实例位于Activity栈的顶部时，就不产生新的实例，而只是调用Activity中的newInstance()方法。如果不位于栈顶，会产生一个新的实例。例：当MainActivity为 singleTop 模式时，执行跳转后栈里面依旧只有一个实例，如果现在按返回键程序将直接退出。<br>3)singleTask： singleTask模式和后面的singleInstance模式都是只创建一个实例的。在这种模式下，无论跳转的对象是不是位于栈顶的activity，程序都不会生成一个新的实例（当然前提是栈里面已经有这个实例）。这种模式相当有用，在以后的多activity开发中，经常会因为跳转的关系导致同个页面生成多个实例，这个在用户体验上始终有点不好，而如果你将对应的activity声明为 singleTask 模式，这种问题将不复存在。<br>4)singleInstance: 设置为 singleInstance 模式的 activity 将独占一个task（感觉task可以理解为进程），独占一个task的activity与其说是activity，倒不如说是一个应用，这个应用与其他activity是独立的，它有自己的上下文activity。</p>
</blockquote>
<p>17.什么是Intent，如何使用？</p>
<blockquote>
<p>Android基本的设计理念是鼓励减少组件间的耦合，因此Android提供了Intent (意图) ，Intent提供了一种通用的消息系统，它允许在你的应用程序与其它的应用程序间传递Intent来执行动作和产生事件。使用Intent可以激活Android应用的三个核心组件：活动、服务和广播接收器。<br>通过startActivity() orstartActivityForResult()启动一个Activity；<br>过 startService() 启动一个服务，或者通过bindService() 和后台服务交互；<br>通过广播方法(比如 sendBroadcast(),sendOrderedBroadcast(),sendStickyBroadcast())发给broadcast receivers</p>
</blockquote>
<p>18.Android用的数据库是什么样的？它和sql有什么区别？为什么要用ContentProvide？它和sql的实现上有什么差别？</p>
<blockquote>
<p>Adnroid用的是SQLite数据库。它和其他网络数据库类似，也是通过SQL对数据进行管理。SQLite的操作非常简单，包括数据类型在建表时也可以不指定。<br>使用ContentProvider 可以将数据共享给其他应用，让除本应用之外的应用也可以访问本应用的数据。它的底层是用SQLite 数据库实现的，所以其对数据做的各种操作都是以Sql实现，只是在上层提供的是Uri。</p>
</blockquote>
<p>19.通过Intent传递一些二进制数据的方法有哪些?</p>
<blockquote>
<p>1)使用Serializable接口实现序列化，这是Java常用的方法。<br>2)实现Parcelable接口，这里Android的部分类比如Bitmap类就已经实现了，同时Parcelable在Android AIDL中交换数据也很常见的。 </p>
</blockquote>
<p>20.对一些资源以及状态的操作保存，最好是保存在生命周期的哪个函数中进行？</p>
<blockquote>
<p>onResume()恢复数据、onPause()保存数据。</p>
</blockquote>
<p>21.如何一次性退出所有打开的Activity</p>
<blockquote>
<p>编写一个Activity作为入口，当需要关闭程序时，可以利用Activity的SingleTop模式跳转该Activity，它上面的所有Activity都会被销毁掉。然后再将该Activity关闭。<br>或者再跳转时，设置intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);这样也能将上面的Activity销毁掉。</p>
</blockquote>
<p>22.说说Service的生命周期？</p>
<blockquote>
<p>启动Service的方式有两种，各自的生命周期也有所不同。<br>一、通过startService启动Service：onCreate、onStartCommand、onDestory。<br>二、通过bindService绑定Service：onCreate、onBind、onUnbind、onDestory。</p>
</blockquote>
<p>23.什么是AIDL？AIDL是如何工作的？</p>
<blockquote>
<p>AIDL(Android接口描述语言)是一种接口描述语言; 编译器可以通过aidl文件生成一段代码，通过预先定义的接口达到两个进程内部通信进程的目的. 如果需要在一个Activity中, 访问另一个Service中的某个对象, 需要先将对象转化成AIDL可识别的参数(可能是多个参数), 然后使用AIDL来传递这些参数, 在消息的接收端, 使用这些参数组装成自己需要的对象。AIDL是基于接口的，但它是轻量级的。它使用代理类在客户端和实现层间传递值.。</p>
</blockquote>
<p>24.Android如何把文件存放在SDCard上？</p>
<blockquote>
<p>在AndroidManifest.xml中加入访问SDCard的权限如下:<br>&lt;!– 在SDCard中创建与删除文件权限 –&gt;</p>
<p><uses-permission android:name="”android.permission.MOUNT_UNMOUNT_FILESYSTEMS”/"><br>&lt;!– 往SDCard写入数据权限 –&gt;</uses-permission></p>
<p><uses-permission android:name="”android.permission.WRITE_EXTERNAL_STORAGE”/"><br>要往SDCard存放文件，程序必须先判断手机是否装有SDCard，并且可以进行读写。<br>注意：访问SDCard必须在AndroidManifest.xml中加入访问SDCard的权限。<br>Environment.getExternalStorageState()方法用于获取SDCard的状态，如果手机装有SDCard，并且可以进行读写，那么方法返回的状态等于Environment.MEDIA_MOUNTED。<br>Environment.getExternalStorageDirectory()方法用于获取SDCard的目录。</uses-permission></p>
</blockquote>
<p>25.注册广播有几种方式，这些方式有何优缺点？</p>
<blockquote>
<p>两种。一种是通过代码注册，这种方式注册的广播会跟随程序的生命周期。二种是在AndroidManifest.xml中配置广播，这种常驻型广播当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行。</p>
</blockquote>
<p>26.什么是ANR 如何避免它? </p>
<blockquote>
<p>在Android上，如果你的应用程序有一段时间响应不够灵敏，系统会向用户显示一个对话框，这个对话框称作应用程序无响应（ANR：Application Not Responding）对话框。用户可以选择让程序继续运行，但是，他们在使用你的应用程序时，并不希望每次都要处理这个对话框。因此，在程序里对响应性能的设计很重要，这样，系统不会显示ANR给用户。要避免它，应该尽量少在主线程做耗时太长的操作，应该将这些操作放在线程当中去做。</p>
</blockquote>
<p>27.Android本身的api并未声明会抛出异常，则其在运行时有无可能抛出runtime异常，你遇到过吗?诺有的话会导致什么问题?如何解决? </p>
<blockquote>
<p>有可能，比如空指针异常、数组下表越界等异常，这些异常抛出后可能会导致程序FC。在编写代码时应该做好检测，多考虑可能会发生错误的情况，从代码层次解决这些问题。</p>
</blockquote>
<p>28.为什么要用 ContentProvider?它和 sql 的实现上有什么差别?</p>
<blockquote>
<p>使用ContentProvider 可以将数据共享给其他应用，让除本应用之外的应用也可以访问本应用的数据。它的底层是用SQLite 数据库实现的，所以其对数据做的各种操作都是以Sql实现，只是在上层提供的是Uri。</p>
</blockquote>
<p>29.谈谈 UI 中, Padding 和 Margin 有什么区别?</p>
<blockquote>
<p>padding指内边距，表示组件内部元素距离组件边框的距离。<br>marin指外边距，表示组件与组件之间的距离。</p>
</blockquote>
<p>30.请介绍下 Android 的数据存储方式。</p>
<blockquote>
<p>Android 提供了5种方式存储数据：<br>1)使用SharedPreferences存储数据；<br>2)文件存储数据；<br>3)SQLite数据库存储数据；<br>4)使用ContentProvider存储数据；<br>5)网络存储数据；</p>
</blockquote>
<h2 id="整理和参考了如下文章："><a href="#整理和参考了如下文章：" class="headerlink" title="整理和参考了如下文章："></a>整理和参考了如下文章：</h2><p>1.<a href="http://www.cnblogs.com/kunyashaw/p/4315186.html" target="_blank" rel="external">android面试题整理（自己给自己充充电吧）</a><br>2.<a href="http://gold.xitu.io/entry/570e6f7471cfe4005bf7888d" target="_blank" rel="external">2016 新浪微博 Android 面试题 | yuweiguo’s blog</a><br>3.<a href="http://www.codeceo.com/article/android-interview-question.html" target="_blank" rel="external">Android工程师面试题大全</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="大弃" />
          <p class="site-author-name" itemprop="name">大弃</p>
          <p class="site-description motion-element" itemprop="description">追求技术的路上永远不能停下脚步。。。</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/">
              <span class="site-state-item-count">5</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大弃</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"ydmmocoo"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  






  
  
  

  

  

</body>
</html>
